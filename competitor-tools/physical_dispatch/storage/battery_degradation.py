# Computes the battery degradation following ESPA model formulations,# which is based on Rosewater, et al 2019import numpy as npimport osimport pandas as pdimport datetimeimport jsonclass Degradation:    def __init__(self, soc_array, temp_array, times_array, storage_df):        self.socs = soc_array        self.temps = temp_array        self._times = times_array        self.rids = ['R00229'] # Arbitrary resource identifier        self.K_time = storage_df.loc[:,'deg_time'].values        self.K_therm = storage_df.loc[:,'deg_therm'].values        self.K_soc = storage_df.loc[:,'deg_soc'].values        self.C_EoL = storage_df.loc[:,'cost_EoL'].values        self.A0 = storage_df.loc[:,'deg_DoD0'].values        self.A1 = storage_df.loc[:,'deg_DoD1'].values        self.A2 = storage_df.loc[:,'deg_DoD2'].values        self.A3 = storage_df.loc[:,'deg_DoD3'].values        self.A4 = storage_df.loc[:,'deg_DoD4'].values        self.A_Tref = storage_df.loc[:,'temp_ref'].values        self.soc_capacity = np.array((storage_df.loc[:,'soc_capacity'].values))        self.socs /= self.soc_capacity[0]        self.A_socref = np.array((storage_df.loc[:,'socref'].values))/self.soc_capacity        self.num_stack = storage_df.loc[:,'cell_count'].values    def compute_degradation_cost(self):        '''        Uses soc/temp/time arrays and battery attributes to compute degradation cost        '''        # Make times an array of differences then convert to minutes        self._times -= self._times[0]        self.times = np.zeros(len(self._times)) # Make a new array of floats instead of datetimes        for i in range(len(self.times)):            # Time in Rosewater paper is in units of hours            self.times[i] = self._times[i].total_seconds() / 3600        degradation_costs = {} # np.zeros(len(self.rids))              for k in range(len(self.rids)):            # Find the average soc and temperature            self.soc = np.sum(self.socs[k,:])/len(self.socs[k,:]) #/(self.times[-1]-self.times[0])            self.temp = np.sum(self.temps[k,:])/len(self.temps[k,:]) #/(self.times[-1]-self.times[0])            # Compute all of the parameters, then find the degradation cost            self.calculate_parameters(k)            # Eqn 120 (give or take) in model_formulations_v1-1            degradation_costs[self.rids[k]] = self.C_EoL[k] * self.dSoH_dt * (self.times[-1]-self.times[0])        if len(degradation_costs) == 1:            key1 = list(degradation_costs.keys())[0]            degradation_costs = degradation_costs[key1]        return degradation_costs        def calculate_parameters(self, idx):        self.F_t = self.K_time[idx]*(self.times[-1]-self.times[0])        self.F_T = np.exp(self.K_therm[idx]*(self.temp-self.A_Tref[idx])*self.A_Tref[idx]/self.temp)        self.F_S = np.exp(self.K_soc[idx]*(self.soc-self.A_socref[idx]))        self.D_vec = self.rainflow(idx)        self.delta = 1/np.sum(self.socs[idx,:])*np.sum(self.D_vec)        # self.delta = np.sum(self.D_vec)/len(self.D_vec)        self.F_D = self.A0[idx] + self.A1[idx]*self.delta + self.A2[idx]*self.delta**2 + \            self.A3[idx]*self.delta**3 + self.A4[idx]*self.delta**4        self.f = self.F_t*self.F_S*self.F_T + np.sum(self.D_vec)*self.F_D*self.F_S*self.F_T        self.dSoH_dt = -self.K_time[idx]*self.F_S*self.F_T*np.exp(-self.f)            def rainflow(self, idx):        # 1: soc profile is self.socs        # 2: remove all non-peak, non-trough values (keeping 1st, last elements)        delete_inds = []        on_plateau = False        incoming_dlt = 0        tol = 0.0001        for i in range(len(self.socs[idx,:])):            if i == 0 or i == len(self.socs[idx,:])-1:                continue            dlt1 = (self.socs[idx,i] - self.socs[idx,i-1])            dlt2 = (self.socs[idx,i+1] - self.socs[idx,i])            # Make sure floating point errors don't count as sign changes            if abs(dlt1) < tol:                dlt1 = 0            if abs(dlt2) < tol:                dlt2 = 0            is_max_min = (dlt1*dlt2)<0            # Logic to handle soc plateau peaks/troughs            if on_plateau and (incoming_dlt*dlt2) < 0:                is_max_min = True            if dlt2 == 0:                if not on_plateau:                    incoming_dlt = dlt1                on_plateau = True            else:                on_plateau = False            if not is_max_min:                delete_inds += [i]        _socs = np.delete(self.socs[idx,:], delete_inds)        # Check that it didn't end on a plateau. If it did, delete the extra        if abs(_socs[-1] - _socs[-2]) < tol:            _socs = np.delete(_socs, -1)        # 3: Reorder so highest peak occurs first and append peak to be the last element        max_idx = np.argmax(_socs)        max_val = _socs[max_idx]        mask = np.arange(len(_socs),dtype=int)+max_idx        mask[mask>=len(mask)] -= len(mask)        _socs = _socs[mask]        _socs = np.append(_socs, max_val)        _socs = list(_socs)        # 4: Create empty vectors R and D (using lists, convert to array at end)        R, D = [], []        while len(_socs) > 0:            if len(_socs)+len(R) < 3:                break            # 5, 6: remove first element from s and insert it at the beginning of R until len(R)==3            while len(R) < 3:                R += [_socs[0]]                _socs.remove(_socs[0])            # 7: Set X and Y as the magnitude differences            X, Y = abs(R[0]-R[1]), abs(R[1]-R[2])            # 8: Check if X >= Y. If so, add Y to vector D and remove 2nd, 3rd elements from R            if X >= Y:                D += [Y]            R = [R[0]]            # 9: Repeat until done        if len(D) == 0:            D = 0        return D    # TODO: The below is just for testing - delete when doneif __name__ == '__main__':    batt_attr_file = '../data/battery_attributes.json'    batt_attr_file = os.path.join(os.getcwd(), batt_attr_file)    soc_temp_file = '../../../docs/Deg_SoC_Temp.xlsx'    soc_temp_file = os.path.join(os.getcwd(),soc_temp_file)    with open(batt_attr_file, 'r') as f:        batt_attr = json.load(f)    # Convert json to dataframe    batt_columns = np.array([k for k in batt_attr.keys()])    batt_values = np.array([v for v in batt_attr.values()])    batt_values = np.reshape(batt_values, (1, len(batt_values))).astype('float')    resource_str = pd.DataFrame(batt_values, columns=batt_columns)    soc_temp = pd.read_excel(soc_temp_file, sheet_name='raw data')    idx1 = 0    idx2 = idx1+288 # One day later = 288 5-minute intervals    soc_array = np.array(soc_temp.loc[idx1:idx2,'soc_R00229'].values)    soc_array = np.reshape(soc_array, (1, len(soc_array)))    temp_array = np.array(soc_temp.loc[idx1:idx2,'temp_R00229'].values)    temp_array = np.reshape(temp_array, (1, len(temp_array)))    times_array = pd.to_datetime(soc_temp.loc[idx1:idx2, 'Time'].values)    battery_deg = Degradation(soc_array, temp_array, times_array, resource_str)    deg_costs = battery_deg.compute_degradation_cost()    print(f"Degradation Cost is ${deg_costs}")