# Computes the battery degradation following ESPA model formulations,# which is based on Rosewater, et al 2019import numpy as npimport osimport pandas as pdimport datetimeimport jsonclass Degradation:    def __init__(self, soc_array, temp_array, current_array, times_array, t_start, storage_df):        self.socs = 1.0*soc_array        self.temps = 1.0*temp_array        self.currents = current_array        self._times = times_array        self.t_start = (t_start-self._times[0]).total_seconds() / 3600 # Hours        self.rids = ['R00229'] # Arbitrary resource identifier        self.resistances = storage_df.loc[:,'resis'].values        self.eff = storage_df.loc[:,'eff_coul'].values        self.therm_cap = storage_df.loc[:,'therm_cap'].values        self.charge_cap = storage_df.loc[:,'ch_cap'].values        self.cycle_life = storage_df.loc[:,'cycle_life']        self.K_time = storage_df.loc[:,'deg_time'].values        self.K_therm = storage_df.loc[:,'deg_therm'].values        self.K_soc = storage_df.loc[:,'deg_soc'].values        self.C_EoL = storage_df.loc[:,'cost_EoL'].values        self.A0 = storage_df.loc[:,'deg_DoD0'].values        self.A1 = storage_df.loc[:,'deg_DoD1'].values        self.A2 = storage_df.loc[:,'deg_DoD2'].values        self.A3 = storage_df.loc[:,'deg_DoD3'].values        self.A4 = storage_df.loc[:,'deg_DoD4'].values        self.A_Tref = storage_df.loc[:,'temp_ref'].values        self.soc_capacity = np.array((storage_df.loc[:,'soc_capacity'].values))        self.socs /= self.soc_capacity[0]        self.A_socref = np.array((storage_df.loc[:,'socref'].values))/self.soc_capacity        self.num_stack = storage_df.loc[:,'cell_count'].values    def compute_degradation_cost(self, method='component'):        '''        Uses soc/temp/time arrays and battery attributes to compute degradation cost        method:        - 'analytic' uses analytic state-of-heath derivative from eqn 131 from            the formulations document:            degradation = cost_EoL * d_SoH/dt * delta_t        - 'component' uses the normalization procedure used to calculate degration using            eqn 138 in the formulation document:            degradation = cost_cyc + cost_therm + cost_SoC + cost_DoD        '''        # Make times an array of differences then convert to minutes        self._times -= self._times[0]        self.times = np.zeros(len(self._times))  # Make a new array of floats instead of datetimes        self.sidx = 0        for i in range(len(self.times)):            # Time in Rosewater paper is in units of hours            time_hrs = self._times[i].total_seconds() / 3600            self.times[i] = time_hrs            if self.times[i] <= self.t_start:                self.sidx += 1        self.dt = self.times[-1] - self.times[0]        degradation_costs = {}  # np.zeros(len(self.rids))        for k in range(len(self.rids)):            # Compute all of the parameters, then find the degradation cost            self.calculate_parameters(k, self.sidx)            if method=='analytic':                # Compute again to get the starting SoH value (self.f_start)                self.dSoH_dt = (np.exp(-self.f_start) - np.exp(-self.f)) / (self.t_start - self.times[-1])                # Eqn 120 (give or take) in model_formulations_v1-1                degradation_costs[self.rids[k]] = self.C_EoL[k] * self.dSoH_dt * (self.times[-1] - self.times[0])            elif method=='component':                self.calculate_cost_cyc(k)                self.calculate_cost_therm(k)                self.calculate_cost_soc(k)                self.calculate_cost_dod(k)                degradation_costs[self.rids[k]] = self._cost_cyc + self._cost_therm + self._cost_soc + self._cost_dod        if len(degradation_costs) == 1:            key1 = list(degradation_costs.keys())[0]            degradation_costs = degradation_costs[key1]        return degradation_costs    def calculate_parameters(self, idx, sidx):        # Find the average soc and temperature        self.soc = np.sum(self.socs[idx, :]) / len(self.socs[idx, :])        self.temp = np.sum(self.temps[idx, :]) / len(self.temps[idx, :])        self.F_t = self.K_time[idx] * self.times[-1] / 1.5  # Total time so far...        self.F_T = np.exp(self.K_therm[idx] * (self.temp - self.A_Tref[idx]) * self.A_Tref[idx] / self.temp)        self.F_S = np.exp(self.K_soc[idx] * (self.soc - self.A_socref[idx]))        self.D_vec = self.rainflow(idx, len(self.times))        if type(self.D_vec) is int:            ld = 1        else:            ld = len(self.D_vec)        self.delta = np.sum(self.D_vec) / ld        self.F_D = self.A0[idx] + self.A1[idx] * self.delta + self.A2[idx] * self.delta ** 2 + \                   self.A3[idx] * self.delta ** 3 + self.A4[idx] * self.delta ** 4        self.F_D /= 10000        self.f = self.F_t * self.F_S * self.F_T + np.sum(self.D_vec) * self.F_D * self.F_S * self.F_T        # Re-do everything to find f at the start of this interval        self.soc_st = np.sum(self.socs[idx, :sidx]) / len(self.socs[idx, :sidx])        self.temp_st = np.sum(self.temps[idx, :sidx]) / len(self.temps[idx, :sidx])        self.F_t_st = self.K_time[idx] * self.t_start / 1.5  # Total time up to start point        self.F_T_st = np.exp(self.K_therm[idx] * (self.temp_st - self.A_Tref[idx]) * self.A_Tref[idx] / self.temp_st)        self.F_S_st = np.exp(self.K_soc[idx] * (self.soc_st - self.A_socref[idx]))        self.D_vec_st = self.rainflow(idx, sidx)        if type(self.D_vec_st) is int:            ld = 1        else:            ld = len(self.D_vec_st)        self.deltas = np.sum(self.D_vec_st) / ld        self.F_D_st = self.A0[idx] + self.A1[idx] * self.deltas + self.A2[idx] * self.deltas ** 2 + \                      self.A3[idx] * self.deltas ** 3 + self.A4[idx] * self.deltas ** 4        self.F_D_st /= 10000        self.f_start = self.F_t_st * self.F_S_st * self.F_T_st + \                       np.sum(self.D_vec_st) * self.F_D_st * self.F_S_st * self.F_T_st    def rainflow(self, idx, sidx):        # 1: soc profile is self.socs        # 2: remove all non-peak, non-trough values (keeping 1st, last elements)        delete_inds = []        on_plateau = False        incoming_dlt = 0        tol = 0.0001        for i in range(len(self.socs[idx,:sidx])):            if i == 0 or i == len(self.socs[idx,:sidx])-1:                continue            dlt1 = (self.socs[idx,i] - self.socs[idx,i-1])            dlt2 = (self.socs[idx,i+1] - self.socs[idx,i])            # Make sure floating point errors don't count as sign changes            if abs(dlt1) < tol:                dlt1 = 0            if abs(dlt2) < tol:                dlt2 = 0            is_max_min = (dlt1*dlt2)<0            # Logic to handle soc plateau peaks/troughs            if on_plateau and (incoming_dlt*dlt2) < 0:                is_max_min = True            if dlt2 == 0:                if not on_plateau:                    incoming_dlt = dlt1                on_plateau = True            else:                on_plateau = False            if not is_max_min:                delete_inds += [i]        _socs = np.delete(self.socs[idx,:sidx], delete_inds)        # Check that it didn't end on a plateau. If it did, delete the extra        if len(_socs) < 2:            return 0        if abs(_socs[-1] - _socs[-2]) < tol:            _socs = np.delete(_socs, -1)        # 3: Reorder so highest peak occurs first and append peak to be the last element        max_idx = np.argmax(_socs)        max_val = _socs[max_idx]        mask = np.arange(len(_socs),dtype=int)+max_idx        mask[mask>=len(mask)] -= len(mask)        _socs = _socs[mask]        _socs = np.append(_socs, max_val)        _socs = list(_socs)        # 4: Create empty vectors R and D (using lists, convert to array at end)        R, D = [], []        add_pt = False        while len(_socs) > 0:            if len(_socs)+len(R) < 3:                break            # 5, 6: remove first element from s and insert it at the beginning of R until len(R)==3            while len(R) < 3:                R = [_socs[0]] + R                _socs.remove(_socs[0])            # Draw the next point as needed            if add_pt:                R = [_socs[0]] + R                _socs.remove(_socs[0])            # 7: Set X and Y as the magnitude differences            X, Y = abs(R[0]-R[1]), abs(R[1]-R[2])            # 8: Check if X >= Y. If so, add Y to vector D and remove 2nd, 3rd elements from R            if X >= Y:                D += [Y]                del R[1:3]                add_pt = False            else:                add_pt = True            # 9: Repeat until done        if len(D) == 0:            D = [0]        return D    def calculate_cost_cyc(self, idx, display=True):        delta_t = self.dt        cost_EoL = self.C_EoL[idx]        efficiency = self.eff[idx]        cycle_life = self.cycle_life[idx]        charge_cap = self.charge_cap[idx]        current = self.currents[idx]        self._cost_cyc = ((delta_t * cost_EoL) / ((1+1/efficiency) * cycle_life * charge_cap )) * np.sum(current)        if display:            print(f'\tcyc:\t{self._cost_cyc}')    def calculate_cost_therm(self, idx, display=True):        epsilon = 1e-6        F_Tpos = np.exp(self.K_therm[idx] * (self.temp + epsilon - self.A_Tref[idx]) * self.A_Tref[idx] / (self.temp + epsilon))        F_Tneg = np.exp(self.K_therm[idx] * (self.temp - epsilon - self.A_Tref[idx]) * self.A_Tref[idx] / (self.temp - epsilon))        f_Tpos = self.F_t * self.F_S * F_Tpos + np.sum(self.D_vec) * self.F_D * self.F_S * F_Tpos        f_Tneg = self.F_t * self.F_S * F_Tneg + np.sum(self.D_vec) * self.F_D * self.F_S * F_Tneg        H_Tpos = -self.K_time[idx] * self.F_S * F_Tpos * np.exp(-f_Tpos)        H_Tneg = -self.K_time[idx] * self.F_S * F_Tneg * np.exp(-f_Tneg)        K_T = (H_Tpos - H_Tneg) / (2*epsilon)        self._cost_therm = ((self.dt**2 * self.C_EoL[idx] * K_T * self.resistances[idx]) / self.therm_cap[idx] ) * np.linalg.norm(self.currents[idx],2)        if display:            print(f'\ttherm:\t{self._cost_therm}')    def calculate_cost_soc(self, idx, display=True):        epsilon = 1e-6        F_Spos = np.exp(self.K_soc[idx] * (self.soc + epsilon - self.A_socref[idx]))        F_Sneg = np.exp(self.K_soc[idx] * (self.soc - epsilon - self.A_socref[idx]))        f_Spos = self.F_t * F_Spos * self.F_T + np.sum(self.D_vec) * self.F_D * F_Spos * self.F_T        f_Sneg = self.F_t * F_Sneg * self.F_T + np.sum(self.D_vec) * self.F_D * F_Sneg * self.F_T        H_Spos = -self.K_time[idx] * F_Spos * self.F_T * np.exp(-f_Spos)        H_Sneg = -self.K_time[idx] * F_Sneg * self.F_T * np.exp(-f_Sneg)        K_S = (H_Spos - H_Sneg) / (2*epsilon)        self._cost_soc = (self.dt * self.C_EoL[idx] * K_S * self.soc)        if display:            print(f'\tsoc:\t{self._cost_soc}')    def calculate_cost_dod(self, idx, display=True):        d_F_D = self.A1[idx] + 2*self.A2[idx]*self.delta + 3*self.A3[idx]*self.delta**2 + 4*self.A4[idx]*self.delta**3        K_D = -self.K_time[idx] * self.F_T * self.F_S * d_F_D * np.exp(self.f)        self._cost_dod = self.C_EoL[idx] * K_D * self.delta        if display:            print(f'\tdod:\t{self._cost_dod}')def test_one_day():    batt_attr_file = '../data/battery_attributes.json'    batt_attr_file = os.path.join(os.getcwd(), batt_attr_file)    for test in ['ConSoC_Temp20', 'ConSoC_Temp30', 'ConSoC_Temp40',                 'RampSoC_Temp20', 'RampSoc_Temp30', 'RampSoc_Temp40']:        soc_temp_file = f'../data/Deg_{test}.xlsx'        soc_temp_file = os.path.join(os.getcwd(), soc_temp_file)        with open(batt_attr_file, 'r') as f:            batt_attr = json.load(f)        # Convert json to dataframe        batt_columns = np.array([k for k in batt_attr.keys()])        batt_values = np.array([v for v in batt_attr.values()])        batt_values = np.reshape(batt_values, (1, len(batt_values))).astype('float')        resource_str = pd.DataFrame(batt_values, columns=batt_columns)        soc_temp = pd.read_excel(soc_temp_file, sheet_name='raw data')        idx1 = 0        idx2 = idx1 + 288  # One day later = 288 5-minute intervals        soc_array = np.array(soc_temp.loc[idx1:idx2, 'soc_R00229'].values)        soc_array = np.reshape(soc_array, (1, len(soc_array)))        temp_array = np.array(soc_temp.loc[idx1:idx2, 'temp_R00229'].values)        temp_array = np.reshape(temp_array, (1, len(temp_array)))        current_array = np.array(soc_temp.loc[idx1:idx2, 'i_R00229'].values)        current_array = np.reshape(current_array, (1, len(current_array)))        times_array = pd.to_datetime(soc_temp.loc[idx1:idx2, 'Time'].values)        battery_deg = Degradation(soc_array, temp_array, current_array, times_array, resource_str)        deg_costs = battery_deg.compute_degradation_cost()        print(f"{test}:\t ${deg_costs}")def test_multiday():    batt_attr_file = '../data/battery_attributes.json'    batt_attr_file = os.path.join(os.getcwd(), batt_attr_file)    soc_temp_file = '../data/Deg_SoC_Temp.xlsx'    soc_temp_file = os.path.join(os.getcwd(), soc_temp_file)    with open(batt_attr_file, 'r') as f:        batt_attr = json.load(f)    # Convert json to dataframe    batt_columns = np.array([k for k in batt_attr.keys()])    batt_values = np.array([v for v in batt_attr.values()])    batt_values = np.reshape(batt_values, (1, len(batt_values))).astype('float')    resource_str = pd.DataFrame(batt_values, columns=batt_columns)    soc_temp = pd.read_excel(soc_temp_file, sheet_name='raw data')    idx1 = 0    for d in range(29):        idx2 = idx1 + 288 * (d + 1)  # One day later = 288 5-minute intervals        # Read in soc, temperature, and times        soc_array = np.array(soc_temp.loc[idx1:idx2, 'soc_R00229'].values)        soc_array = np.reshape(soc_array, (1, len(soc_array)))        temp_array = np.array(soc_temp.loc[idx1:idx2, 'temp_R00229'].values)        temp_array = np.reshape(temp_array, (1, len(temp_array)))        current_array = np.array(soc_temp.loc[idx1:idx2, 'i_R00229'].values)        current_array = np.reshape(current_array, (1, len(current_array)))        times_array = pd.to_datetime(soc_temp.loc[idx1:idx2, 'Time'].values)        t_start = times_array[-289]        # Compute the degradation cost        battery_deg = Degradation(soc_array, temp_array, current_array, times_array, t_start, resource_str)        deg_costs = battery_deg.compute_degradation_cost()        print(f"Degradation Cost on day {d + 1} is ${deg_costs}")if __name__ == '__main__':    test_multiday()